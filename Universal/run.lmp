# =============================================================================
# =============================================================================
#
# NPT Equilibration of Liquid Box of Water Solution
# Written By: Amro Dodin
#
# =============================================================================
# =============================================================================

# =============================================================================
# Read in Configuration & Parameters
# =============================================================================

# Initialize Parameters
include parameters.lmp
include parse_model.lmp

# Read in Data From init Script
atom_style full
pair_style soft 3.0
bond_style harmonic 
angle_style harmonic
improper_style harmonic

if "${pol} == Drude" then &
    "variable label string ${pol}.${label}" &
    "variable FFLabel string ${pol}.${FFLabel}"

if "${skipEquil}==False" then &
    "read_data ${DATADIR}data.${label}.init" &
else &
    "read_data ${DATADIR}data.${label}.eq nocoeff" &
    "bond_coeff * 0 0" &
    "angle_coeff * 0 0" &
    "improper_coeff * 0 0" 

if "${BC} == electrode" then &
    "variable label string ${label}.pot.${pot}"

if "${pol} == ECC" then &
    "variable label string ${pol}.${label}" &
    "variable FFLabel string ${pol}.${FFLabel}"

log ${DATADIR}eq.${label}.log

# Read in Force Field
include ${FFDIR}ff.${FFLabel}.lmp
#delete_bonds all multi 
neighbor 2.0 bin
neigh_modify delay 0

# =============================================================================
# Set Up Groups
# =============================================================================

group waters type 1:${numWaterTypes}
group cations type $((v_numWaterTypes+1)):$((v_numWaterTypes+v_numCationTypes))
group anions type $((v_numWaterTypes+v_numCationTypes+1)):$((v_numWaterTypes+v_numCationTypes+v_numAnionTypes))
if "${BC} == electrode" then &
    "group electrodes type $((v_numWaterTypes+v_numCationTypes+v_numAnionTypes+1)):$((v_numWaterTypes+v_numCationTypes+v_numAnionTypes+v_numBCTypes))" &
    "region rbot block EDGE EDGE EDGE EDGE EDGE 0" &
    "region rtop block EDGE EDGE EDGE EDGE 0 EDGE" &
    "group allbot region rbot" &
    "group alltop region rtop" &
    "group bot intersect electrodes allbot" &
    "group top intersect electrodes alltop" &
else &
    "group electrodes empty"
group mobile subtract all electrodes

reset_mol_ids mobile single yes

if "${pol} == Drude" then &
    "jump SELF skipCharges"

if "${cationMolecular}==False" then &
    "set type ${cationType} charge ${qCation}"

if "${anionMolecular}==False" then &
    "set type ${anionType} charge ${qAnion}"


label skipCharges

if "${cationMolecular}==True && ${anionMolecular}==True" then &
    "group molecular union waters cations anions" &
    "group simple empty" &
elif "${cationMolecular}==True && ${anionMolecular}==False" &
    "group molecular union waters cations" &
    "group simple union anions" &
elif "${cationMolecular}==False && ${anionMolecular}==True" &
    "group molecular union waters anions" &
    "group simple union cations" &
else &
    "group molecular union waters" &
    "group simple union cations anions" 

if "${pol} == Drude" then &
    "group ATOMS type 1:${atomTypes}" &
    "group DRUDE type ${DrudeTypesLower}:${DrudeTypesUpper}"

# =============================================================================
# Set Up ECC scaling
# =============================================================================

if "${pol} == ECC" then &
    "variable charge atom v_ECC*q" &
    "set type ${anionType} charge v_charge" & 
    "set type ${cationType} charge v_charge" 

# =============================================================================
# Set Up Overall Integration Fixes
# =============================================================================

timestep ${dt}

if "${BC} == wall" then &
    "change_box all boundary p p f" &
    "kspace_modify slab 3.0" &
    "fix wall all wall/lj126 zlo EDGE 0.1 ${ljRAu} 12.0 zhi EDGE 0.1 ${ljRAu} 12.0 units box" &
elif "${BC} == electrode" &
    "change_box all boundary p p f" &
    "kspace_modify slab 3.0" &
    "fix conp bot electrode/conp -$((v_pot/2)) ${eta} couple top $((v_pot/2)) symm on"

variable thermo_spec string "step v_TTarget temp pe density ke"


# =============================================================================
# Add Bias Potentials
# =============================================================================

# Create Group of All Biased Atoms to Exclude from COM Biasing
group biased union anions cations

# z Biases
# -----------------------------------------------------------------------------

# Check if no zBias specified
if "${zBias} == False" then &
    "jump SELF zBreak"

variable zBiasCounter string 0

# If zBias specified loop through biases
label zLoop

variable zBiasCounter string $(v_zBiasCounter+1)

variable negative string 1

# Check if ion type is specified & assign ID
if "${zBias} == id" then &
    "next zBias" &
    "variable zBiasID string ${zBias}" &
    "variable label string ${label}.z.id${zBias}" &
elif "${zBias} == c" &
    "next zBias" &
    "variable zBiasID string $(count(waters)+v_zBias)" &
    "variable label string ${label}.z.c${zBias}" &
elif "${zBias} == a" &
    "next zBias" &
    "variable zBiasID string $(count(waters)+count(cations)+v_zBias)" &
    "variable label string ${label}.z.a${zBias}" &
elif "${zBias} == idm" &
    "next zBias" &
    "variable zBiasID string ${zBias}" &
    "variable negative string -1" &
    "variable label string ${label}.z.id${zBias}" &
elif "${zBias} == cm" &
    "next zBias" &
    "variable zBiasID string $(count(waters)+v_zBias)" &
    "variable negative string -1" &
    "variable label string ${label}.z.c${zBias}" &
elif "${zBias} == am" &
    "next zBias" &
    "variable zBiasID string $(count(waters)+count(cations)+v_zBias)" &
    "variable negative string -1" &
    "variable label string ${label}.z.a${zBias}" &
else &
    "print 'ERROR: first zBias specifier must be c/s/id[m].'" &
    "quit 1"

# Assign Equilibrium position & spring constant
next zBias
variable z0 string $(v_zBias*v_negative)
variable zTarget${zBiasCounter} equal ${z0}
next zBias
variable k string ${zBias}

# Compute Expected Deviation
variable zStDev${zBiasCounter} equal sqrt(v_kT/${k})

print "zBias:"
print "ID: ${zBiasID}"
print "z0: ${z0}"
print "k: $k"
# Create Fix & Add to Thermodynamic Output
group zGroup${zBiasCounter} id ${zBiasID}
group zGroup${zBiasCounter} include molecule
group biased union biased zGroup${zBiasCounter}
fix zBias${zBiasCounter} zGroup${zBiasCounter} spring tether $k NULL NULL ${z0} 0
compute z${zBiasCounter} zGroup${zBiasCounter} com
variable zDev${zBiasCounter} equal (c_z${zBiasCounter}[3]-v_zTarget${zBiasCounter})/v_zStDev${zBiasCounter}
variable thermo_spec string "${thermo_spec} v_zTarget${zBiasCounter} c_z${zBiasCounter}[3] f_zBias${zBiasCounter}"

variable label string ${label}.${z0}.k.${k}

# Parse Next zBias
next zBias
jump SELF zLoop
    
label zBreak

# z Biases
# -----------------------------------------------------------------------------

# Check if no zBias specified
if "${rBias} == False" then &
    "jump SELF rBreak"

variable rBiasCounter string 0

# If zBias specified loop through biases
label rLoop

variable rBiasCounter string $(v_rBiasCounter+1)

variable negative string 1

# Check if ion type is specified & assign ID
if "${rBias} == id" then &
    "next rBias" &
    "variable rBiasID1 string ${rBias}" &
    "variable label string ${label}.r.id${rBias}" &
    "next rBias" &
elif "${rBias} == c" &
    "next rBias" &
    "variable rBiasID1 string $(count(waters)+v_rBias)" &
    "variable label string ${label}.r.c${rBias}" &
    "next rBias" &
elif "${rBias} == a" &
    "next rBias" &
    "variable rBiasID1 string $(count(waters)+count(cations)+v_rBias)" &
    "variable label string ${label}.r.a${rBias}" &
    "next rBias" &
else &
    "print 'ERROR: first rBias specifier must be c/s/id.'" &
    "quit 1"

if "${rBias} == id" then &
    "next rBias" &
    "variable rBiasID2 string ${rBias}" &
    "variable label string ${label}.id${rBias}" &
elif "${rBias} == c" &
    "next rBias" &
    "variable rBiasID2 string $(count(waters)+v_rBias)" &
    "variable label string ${label}.c${rBias}" &
elif "${rBias} == a" &
    "next rBias" &
    "variable rBiasID2 string $(count(waters)+count(cations)+v_rBias)" &
    "variable label string ${label}.a${rBias}" &
else &
    "print 'ERROR: first rBias specifier must be c/s/id.'" &
    "quit 1"

# Assign Equilibrium position & spring constant
next rBias
variable r0 string ${rBias}
variable rTarget${rBiasCounter} equal ${r0}
next rBias
variable k string ${rBias}

# Compute Expected Deviation
variable rStDev${rBiasCounter} equal sqrt(v_kT/${k})

print "rBias:"
print "ID1: ${rBiasID1}"
print "ID2: ${rBiasID2}"
print "r0: ${r0}"
print "k: $k"

# Create Fix & Add to Thermodynamic Output
group rGroup${rBiasCounter}_1 id ${rBiasID1}
group rGroup${rBiasCounter}_1 include molecule
group rGroup${rBiasCounter}_2 id ${rBiasID2}
group rGroup${rBiasCounter}_2 include molecule
group biased union biased rGroup${rBiasCounter}_1 rGroup${rBiasCounter}_2
fix rBias${rBiasCounter} rGroup${rBiasCounter}_1 spring couple rGroup${rBiasCounter}_2 $k 0 0 0 ${r0}
compute r${rBiasCounter}_1 rGroup${rBiasCounter}_1 com
compute r${rBiasCounter}_2 rGroup${rBiasCounter}_2 com
variable r${rBiasCounter} equal sqrt((c_r${rBiasCounter}_1[1]-c_r${rBiasCounter}_2[1])^2+(c_r${rBiasCounter}_1[2]-c_r${rBiasCounter}_2[2])^2+(c_r${rBiasCounter}_1[3]-c_r${rBiasCounter}_2[3])^2)
variable rDev${rBiasCounter} equal (v_r${rBiasCounter}-v_rTarget${rBiasCounter})/v_rStDev${rBiasCounter}
variable thermo_spec string "${thermo_spec} v_rTarget${rBiasCounter} v_r${rBiasCounter} f_rBias${rBiasCounter}"

variable label string ${label}.${r0}.k.$k

# Parse Next zBias
next rBias
jump SELF rLoop
    
label rBreak

# COM Biases
# -----------------------------------------------------------------------------

if "${comBias} == 0" then &
    "jump SELF comBreak"

variable cStDev equal sqrt(v_kT/${comBias})

variable comTarget equal 0
group comGroup subtract all biased
fix comBias comGroup spring tether ${comBias} NULL NULL 0 0
compute COM comGroup com

variable cDev equal (c_COM[3])/v_cStDev

variable thermo_spec string "${thermo_spec} v_comTarget c_COM[3] v_cDev"

label comBreak

# =============================================================================
# Set Up Outputs
# =============================================================================

variable TTarget equal ramp(1,$T)

thermo_style custom ${thermo_spec}
compute myTemp mobile temp
thermo_modify temp myTemp
thermo ${thermoEvery}

dump 1 all custom ${atomEvery} ${DATADIR}eq.${label}.lammpstrj id mol type q x y z vx vy vz ix iy iz
#dump 1 all custom 1 ${DATADIR}eq.${label}.lammpstrj id mol type q x y z vx vy vz fx fy fz ix iy iz
if "$((count(biased))) > 0" then &
    "dump 2 biased custom ${cvEvery} ${DATADIR}bias.eq.${label}.lammpstrj id mol type x y z"

if "${skipEquil}==True" then &
    "jump SELF production"


fix stabilize mobile nve/limit 0.1
run ${nStabilize}
unfix stabilize

velocity all set 0 0 0
if "${pol} == Drude" then &
    "delete_bonds ATOMS multi" &
else &
    "delete_bonds all multi "

# =============================================================================
# Run Heating
# =============================================================================

if "${pol} == Drude" then &
    "fix DrudeDirect all drude/transform/direct"
fix rigidNVT molecular rigid/nvt molecule temp 1 $T ${gtTEquil} tparam 10 10 3
fix simpleNVT simple nvt temp 1 $T ${gtT} tloop 10 tchain 10
if "${pol} == Drude" then &
    "fix DrudeNVT DRUDE nvt temp 1 ${TD} ${gtTDEquil}" &
    "fix DrudeInverse all drude/transform/inverse"

run ${nHeat}


# =============================================================================
# Run Equilibration
# =============================================================================

if "${pol} == Drude" then &
    "unfix DrudeDirect" &
    "unfix DrudeNVT" &
    "unfix DrudeInverse"
unfix rigidNVT
unfix simpleNVT
variable TTarget equal $T

if "${pol} == Drude" then &
    "fix DrudeDirect all drude/transform/direct"
fix rigidNVT molecular rigid/nvt molecule temp $T $T ${gtTEquil} tparam 10 10 3
fix simpleNVT simple nvt temp $T $T ${gtT} tloop 10 tchain 10
if "${pol} == Drude" then &
    "fix DrudeNVT DRUDE nvt temp ${TD} ${TD} ${gtTDEquil}" &
    "fix DrudeInverse all drude/transform/inverse"

compute cz all chunk/atom bin/1d z center 0.5

run ${nEquil}

write_data ${DATADIR}data.${label}.eq pair ij

# =============================================================================
# Run Production
# =============================================================================

label production

if "${skipProd}==True" then &
    quit

undump 1
if "$((count(biased))) > 0" then &
    "undump 2"
reset_timestep 0

if "${pol} == Drude" then &
    "unfix DrudeDirect" &
    "unfix DrudeNVT" &
    "unfix DrudeInverse"
unfix rigidNVT
unfix simpleNVT

log ${DATADIR}eq.${label}.log

if "${skipEquil}==True" then &
    "read_dump ${DATADIR}eq.${label}.lammpstrj ${nEquil} x y z vx vy vz q ix iy iz" &
    "reset_timestep 0"

variable TTarget equal $T

if "${pol} == Drude" then &
    "fix DrudeDirect all drude/transform/direct"
fix rigidNVT molecular rigid/nvt molecule temp $T $T ${gtT} tparam 10 10 3
fix simpleNVT simple nvt temp $T $T ${gtT} tloop 10 tchain 10
if "${pol} == Drude" then &
    "fix DrudeNVT DRUDE nvt temp ${TD} ${TD} ${gtTD}" &
    "fix DrudeInverse all drude/transform/inverse"

dump 1 all custom ${atomEvery} ${DATADIR}prod.${label}.lammpstrj id mol type q x y z vx vy vz ix iy iz
if "$((count(biased))) > 0" then &
    "dump 2 biased custom ${cvEvery} ${DATADIR}bias.prod.${label}.lammpstrj id mol type x y z"

run ${nProd}

write_data ${DATADIR}data.${label}.prod pair ij